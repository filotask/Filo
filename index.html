<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FiloTrack - Project Management System</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
        body { font-family: 'Inter', sans-serif; }
        /* ... (all your existing CSS styles remain unchanged here) ... */
    </style>
</head>
<body class="bg-gray-100 min-h-screen">
    <div id="loginScreen" class="min-h-screen flex items-center justify-center p-4 login-gradient">
        </div>

    <div id="dashboard" class="hidden">
        </div>

    <script>
        // --- SUPABASE SETUP ---
        const SUPABASE_URL = 'https://kiltzkbpdanhyrvfcbiv.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImtpbHR6a2JwZGFuaHlydmZjYml2Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTY1NjgyNzUsImV4cCI6MjA3MjE0NDI3NX0.-5uNx4506fdgkqyecvM8dLGQ1DhlG-0m1GiLUX3TVcQ';
        const supabase = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

        // --- GLOBAL STATE ---
        let currentUser = null; // Will hold profile data
        let allUsers = []; // Will hold all profiles
        let projects = [];
        let tasks = [];
        let messages = [];
        let notifications = [];

        let sidebarCollapsed = false;
        let isDarkMode = JSON.parse(localStorage.getItem('FiloTrack_darkMode')) || false;
        let selectedChatUser = null;

        // --- AUTHENTICATION ---
        document.getElementById('loginForm').addEventListener('submit', async function(e) {
            e.preventDefault();
            const email = document.getElementById('loginEmail').value;
            const password = document.getElementById('loginPassword').value;

            const { data, error } = await supabase.auth.signInWithPassword({ email, password });

            if (error) {
                alert('Login failed: ' + error.message);
            }
            // onAuthStateChange will handle successful login
        });

        document.getElementById('logoutBtn').addEventListener('click', async () => {
            await supabase.auth.signOut();
            // onAuthStateChange will handle logout
            window.location.reload(); // Simple way to reset state
        });

        supabase.auth.onAuthStateChange(async (event, session) => {
            if (event === 'SIGNED_IN' && session) {
                await initializeUser(session.user);
            } else if (event === 'SIGNED_OUT') {
                document.getElementById('dashboard').classList.add('hidden');
                document.getElementById('loginScreen').classList.remove('hidden');
                currentUser = null;
            }
        });

        // --- INITIALIZATION ---
        async function initializeUser(user) {
            // Fetch the user's profile from the 'profiles' table
            const { data: profile, error } = await supabase
                .from('profiles')
                .select('*')
                .eq('id', user.id)
                .single();

            if (error) {
                console.error('Error fetching user profile:', error);
                alert('Could not load your profile.');
                await supabase.auth.signOut();
                return;
            }

            currentUser = profile;
            showDashboard();
            await loadAllData();
            setupRealtimeSubscriptions();
        }
        
        // Load initial data for the application
        async function loadAllData() {
            // Fetch all users/profiles
            let { data: profilesData } = await supabase.from('profiles').select('*');
            allUsers = profilesData || [];

            // Fetch projects
            let { data: projectsData } = await supabase.from('projects').select('*');
            projects = projectsData || [];
            
            // Fetch tasks
            let { data: tasksData } = await supabase.from('tasks').select('*');
            tasks = tasksData || [];

            // Fetch messages involving the current user
            let { data: messagesData } = await supabase.from('messages')
                .select('*')
                .or(`sender_id.eq.${currentUser.id},receiver_id.eq.${currentUser.id}`);
            messages = messagesData || [];
            
            // Fetch notifications for the current user
            let { data: notificationsData } = await supabase.from('notifications')
                .select('*')
                .eq('user_id', currentUser.id);
            notifications = notificationsData || [];
            
            // Initial render of all components
            renderDashboardCards();
            renderProjects();
            renderTasks();
            renderUsers();
            renderChatUsers();
            updateNotificationBadge();
        }

        // --- REAL-TIME SUBSCRIPTIONS ---
        function setupRealtimeSubscriptions() {
            // Listen to changes in Tasks
            supabase.channel('public:tasks')
                .on('postgres_changes', { event: '*', schema: 'public', table: 'tasks' }, async (payload) => {
                    await handleRealtimeChange(tasks, payload, 'id');
                    renderDashboardCards();
                    renderTasks();
                    renderProjects();
                })
                .subscribe();

            // Listen to changes in Projects
            supabase.channel('public:projects')
                .on('postgres_changes', { event: '*', schema: 'public', table: 'projects' }, async (payload) => {
                    await handleRealtimeChange(projects, payload, 'id');
                    renderProjects();
                })
                .subscribe();

            // Listen to new messages for the current user
             supabase.channel('public:messages')
                .on('postgres_changes', { event: 'INSERT', schema: 'public', table: 'messages', filter: `receiver_id=eq.${currentUser.id}` }, async (payload) => {
                    messages.push(payload.new);
                    renderChatUsers();
                    if(selectedChatUser && selectedChatUser.id === payload.new.sender_id) {
                        renderChatMessages();
                    }
                    // Create and fetch new notification
                    await createNotification(payload.new.receiver_id, 'new_message', `New message from ${allUsers.find(u=>u.id === payload.new.sender_id)?.name || '...'}`, null, payload.new.id);
                })
                .subscribe();
        }

        // Generic handler for realtime updates
        function handleRealtimeChange(localArray, payload, key) {
            const { eventType, new: newRecord, old: oldRecord } = payload;
            if (eventType === 'INSERT') {
                localArray.push(newRecord);
            } else if (eventType === 'UPDATE') {
                const index = localArray.findIndex(item => item[key] === newRecord[key]);
                if (index !== -1) localArray[index] = newRecord;
            } else if (eventType === 'DELETE') {
                const index = localArray.findIndex(item => item[key] === oldRecord[key]);
                if (index !== -1) localArray.splice(index, 1);
            }
        }


        // --- NOTIFICATION SYSTEM (MODIFIED) ---
        async function createNotification(userId, type, message, taskId = null, messageId = null) {
            const { data, error } = await supabase.from('notifications').insert({
                user_id: userId,
                type: type,
                message: message,
                task_id: taskId,
                message_id: messageId,
                read: false
            }).select().single();
            
            if(data) notifications.push(data);
            updateNotificationBadge();
        }
        
        async function markNotificationAsRead(notificationId) {
             const { error } = await supabase.from('notifications')
                .update({ read: true })
                .eq('id', notificationId);

            if (!error) {
                const notification = notifications.find(n => n.id === notificationId);
                if (notification) notification.read = true;
                updateNotificationBadge();
            }
        }


        // --- TASK MANAGEMENT (MODIFIED) ---
        document.getElementById('taskForm').addEventListener('submit', async function(e) {
            e.preventDefault();
            const taskData = {
                title: document.getElementById('taskTitle').value,
                description: document.getElementById('taskDescription').value,
                project_id: parseInt(document.getElementById('taskProject').value),
                assignee: document.getElementById('taskAssignee').value,
                priority: document.getElementById('taskPriority').value,
                due_date: document.getElementById('taskDueDate').value,
                created_by: currentUser.id
            };

            let result;
            if (window.editingTaskId) {
                // Update
                result = await supabase.from('tasks').update(taskData).eq('id', window.editingTaskId);
            } else {
                // Create
                taskData.status = 'todo';
                result = await supabase.from('tasks').insert(taskData);
                // Create notification for assigned user
                if (taskData.assignee !== currentUser.id) {
                    await createNotification(
                        taskData.assignee,
                        'task_assigned',
                        `New task assigned: "${taskData.title}" by ${currentUser.name}`,
                        result.data ? result.data[0].id : null
                    );
                }
            }
            
            if (result.error) {
                alert('Error saving task: ' + result.error.message);
            } else {
                document.getElementById('taskModal').classList.add('hidden');
                document.getElementById('taskForm').reset();
            }
            window.editingTaskId = null;
        });

        async function updateTaskStatus(taskId, newStatus) {
            const { error } = await supabase.from('tasks')
                .update({ status: newStatus })
                .eq('id', taskId);
            
            if (error) {
                alert('Error updating status: ' + error.message);
            }
        }
        
        async function deleteTask(taskId) {
            if (confirm('Are you sure you want to delete this task?')) {
                await supabase.from('tasks').delete().eq('id', taskId);
            }
        }

        // --- PROJECT MANAGEMENT (MODIFIED) ---
        document.getElementById('projectForm').addEventListener('submit', async function(e) {
            e.preventDefault();
            const projectData = {
                name: document.getElementById('projectName').value,
                description: document.getElementById('projectDescription').value,
                start_date: document.getElementById('projectStartDate').value,
                end_date: document.getElementById('projectEndDate').value,
                created_by: currentUser.id
            };

            let result;
            if(window.editingProjectId) {
                result = await supabase.from('projects').update(projectData).eq('id', window.editingProjectId);
            } else {
                projectData.status = 'planning';
                result = await supabase.from('projects').insert(projectData);
            }
            
            if(result.error) {
                alert('Error saving project: ' + result.error.message);
            } else {
                 document.getElementById('projectModal').classList.add('hidden');
                 document.getElementById('projectForm').reset();
            }
            window.editingProjectId = null;
        });

        async function deleteProject(projectId) {
            if (confirm('Are you sure you want to delete this project? This will also delete all associated tasks.')) {
                await supabase.from('projects').delete().eq('id', projectId);
            }
        }

        // --- USER MANAGEMENT (MODIFIED) ---
        // Note: Sign up is handled in Supabase dashboard. This modal edits profiles.
        document.getElementById('addUserBtn').addEventListener('click', function() {
            // This button's purpose shifts to inviting users, which is a more complex flow.
            // For now, it will open a disabled form. Users should be added via Supabase UI.
            alert("Please add new users via the Supabase Authentication dashboard.");
        });

        function renderUsers() {
            const usersList = document.getElementById('usersList');
            // The global 'allUsers' array is used here now
            usersList.innerHTML = allUsers.map(user => {
                const avatarContent = user.profile_picture_url 
                    ? `<img src="${user.profile_picture_url}" class="w-full h-full object-cover">`
                    : getInitials(user.name || 'No Name');

                return `
                <tr>
                    <td class="px-6 py-4">
                        <div class="flex items-center space-x-3">
                            <div class="w-10 h-10 bg-blue-500 rounded-full flex items-center justify-center text-white font-semibold text-sm overflow-hidden">
                                ${avatarContent}
                            </div>
                            <div>
                                <div class="text-sm font-medium text-gray-900">${user.name || 'Unnamed User'}</div>
                                <div class="text-sm text-gray-500">${user.email || 'No email'}</div>
                            </div>
                        </div>
                    </td>
                    <td class="px-6 py-4">
                        <div class="text-sm text-gray-900">${user.phone || 'Not provided'}</div>
                        <div class="text-sm text-gray-500">${user.address ? user.address.substring(0, 30) + (user.address.length > 30 ? '...' : '') : 'No address'}</div>
                    </td>
                    <td class="px-6 py-4">
                        <span class="px-2 py-1 rounded-full text-xs font-medium ${user.role === 'admin' ? 'bg-purple-100 text-purple-800' : user.role === 'trainee' ? 'bg-yellow-100 text-yellow-800' : 'bg-blue-100 text-blue-800'}">
                            ${user.role}
                        </span>
                    </td>
                    <td class="px-6 py-4 text-sm">
                        <div class="flex space-x-2">
                           </div>
                    </td>
                </tr>`;
            }).join('');
        }

        // --- PROFILE MANAGEMENT (MODIFIED) ---
        document.getElementById('updateProfileBtn').addEventListener('click', async function() {
            const updates = {
                name: document.getElementById('profileName').value,
                phone: document.getElementById('profilePhone').value,
                address: document.getElementById('profileAddress').value
            };
            
            // Handle file upload
            const profileFile = document.getElementById('profilePictureFile').files[0];
            if (profileFile) {
                const fileName = `${currentUser.id}/${Date.now()}_${profileFile.name}`;
                const { error: uploadError } = await supabase.storage
                    .from('avatars')
                    .upload(fileName, profileFile);

                if (uploadError) {
                    alert('Error uploading picture: ' + uploadError.message);
                } else {
                    const { data: { publicUrl } } = supabase.storage.from('avatars').getPublicUrl(fileName);
                    updates.profile_picture_url = publicUrl;
                }
            }

            const { data, error } = await supabase.from('profiles')
                .update(updates)
                .eq('id', currentUser.id)
                .select()
                .single();

            if (error) {
                alert('Error updating profile: ' + error.message);
            } else {
                currentUser = data; // Update local state with new profile data
                updateAllProfileDisplays();
                updateProfileForm();
                alert('Profile updated successfully!');
            }
        });
        
        function updateProfileForm() {
            document.getElementById('profileName').value = currentUser.name || '';
            document.getElementById('profileEmail').value = currentUser.email || '';
            document.getElementById('profilePhone').value = currentUser.phone || '';
            document.getElementById('profileAddress').value = currentUser.address || '';
            
            document.getElementById('profileDisplayName').textContent = currentUser.name;
            document.getElementById('profileDisplayRole').textContent = currentUser.role.charAt(0).toUpperCase() + currentUser.role.slice(1);
            
            updateProfilePictureDisplay();
        }
        
        function updateProfilePictureDisplay() {
             const avatars = document.querySelectorAll('#profileAvatar, #sidebarAvatar, #headerProfileBtn');
             const initials = getInitials(currentUser.name || 'NN');
            
             avatars.forEach(avatar => {
                const innerSpan = avatar.querySelector('span');
                if (currentUser.profile_picture_url) {
                    avatar.style.backgroundImage = `url(${currentUser.profile_picture_url})`;
                    avatar.style.backgroundSize = 'cover';
                    avatar.style.backgroundPosition = 'center';
                    if(innerSpan) innerSpan.textContent = '';
                } else {
                    avatar.style.backgroundImage = '';
                    if(innerSpan) innerSpan.textContent = initials;
                }
            });
        }
        
        // --- CHAT SYSTEM (MODIFIED) ---
        async function sendMessage() {
            if (!selectedChatUser) return;
            const content = document.getElementById('messageInput').value.trim();
            if (!content) return;

            const { error } = await supabase.from('messages').insert({
                sender_id: currentUser.id,
                receiver_id: selectedChatUser.id,
                content: content
            });

            if (error) {
                alert('Could not send message: ' + error.message);
            } else {
                // The realtime subscription will handle adding the message visually for the receiver.
                // For the sender, we can add it optimistically.
                messages.push({
                    sender_id: currentUser.id,
                    receiver_id: selectedChatUser.id,
                    content: content,
                    created_at: new Date().toISOString()
                });
                renderChatMessages();
                document.getElementById('messageInput').value = '';
            }
        }
        
        function renderChatUsers() {
            const chatUsersList = document.getElementById('chatUsersList');
            const otherUsers = allUsers.filter(u => u.id !== currentUser.id);
            
            chatUsersList.innerHTML = otherUsers.map(user => {
                const unreadCount = messages.filter(m => m.sender_id === user.id && m.receiver_id === currentUser.id && !m.read).length;
                const avatarContent = user.profile_picture_url
                    ? `<img src="${user.profile_picture_url}" class="w-full h-full object-cover">`
                    : getInitials(user.name || 'NN');

                return `
                    <div class="p-4 border-b border-gray-100 hover:bg-gray-50 cursor-pointer" onclick="selectChatUser('${user.id}')">
                         <div class="flex items-center space-x-3">
                            <div class="relative">
                                <div class="w-12 h-12 bg-blue-500 rounded-full flex items-center justify-center text-white font-semibold overflow-hidden">
                                    ${avatarContent}
                                </div>
                                ${unreadCount > 0 ? `<div class="absolute -top-1 -right-1 w-5 h-5 bg-red-500 rounded-full flex items-center justify-center text-xs text-white">${unreadCount}</div>` : ''}
                            </div>
                            <div class="flex-1 min-w-0">
                               <h4 class="font-medium text-gray-800 truncate">${user.name}</h4>
                                </div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        async function selectChatUser(userId) {
            selectedChatUser = allUsers.find(u => u.id === userId);
            // ... (rest of the selectChatUser logic, no changes needed)
            
            // Mark messages as read
            await supabase.from('messages')
                .update({ read: true })
                .eq('sender_id', userId)
                .eq('receiver_id', currentUser.id);
                
            messages.forEach(m => {
                if(m.sender_id === userId && m.receiver_id === currentUser.id) m.read = true;
            });

            renderChatMessages();
            renderChatUsers();
        }

        // --- UTILITY & OTHER FUNCTIONS (Mostly Unchanged) ---
        // Includes: getInitials, showDashboard, updateAllProfileDisplays, sidebarToggle,
        // navigation, section switching, dashboard card rendering, etc.
        // A few minor tweaks were made above to use new data structures.
        
        // Example of a function that remains mostly the same, but uses new variables:
        function showDashboard() {
            document.getElementById('loginScreen').classList.add('hidden');
            document.getElementById('dashboard').classList.remove('hidden');
            
            updateAllProfileDisplays();
            
            if (currentUser.role === 'admin' || currentUser.role === 'manager') {
                document.getElementById('adminNav').classList.remove('hidden');
                document.getElementById('addTaskBtn').classList.remove('hidden');
                document.getElementById('addProjectBtn').classList.remove('hidden');
            } else {
                 document.getElementById('adminNav').classList.add('hidden');
            }
            
            updateProfileForm();
            showSection('dashboard');
        }

        function updateAllProfileDisplays() {
            const initials = getInitials(currentUser.name || 'NN');
            document.getElementById('dropdownUserName').textContent = currentUser.name;
            document.getElementById('dropdownUserRole').textContent = currentUser.role.charAt(0).toUpperCase() + currentUser.role.slice(1);
            document.getElementById('sidebarUserName').textContent = currentUser.name;
            document.getElementById('sidebarUserRole').textContent = currentUser.role.charAt(0).toUpperCase() + currentUser.role.slice(1);
            updateProfilePictureDisplay();
        }

        // --- All other rendering and UI functions from your original script go here ---
        // (renderDashboardCards, renderTasks, renderProjects, etc.)
        // IMPORTANT: Ensure they use the new global variables (allUsers, projects, tasks)
        // and reference properties with new names (e.g., user.profile_picture_url)
        
        // Paste the remaining JS functions from your original file here, making sure to adapt
        // them to the new data source (global arrays) instead of re-fetching data inside each render.
        // The core logic inside them (generating HTML) will be largely the same.
        
        // (Full script omitted for brevity, as the core changes are above)
        // You should now merge the remaining functions from your script into this one.

    </script>
</body>
</html>
